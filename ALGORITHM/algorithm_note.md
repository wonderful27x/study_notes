## 时间复杂度
> O(1)<O(logn)<O(n)<(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

## 线性表
> 定义: 零个或多个数据元素的有限序列。它是有序的，每个元素有且只有一个前驱和后继

### 线性表的基本操作
* create: 初始化，创建空的线性表
* empty: 判断是否为空
* clear: 清空线性表
* size: 返回表中元素的数量
* find: 查找值为e的元素
* get: 获取第i个位置的元素
* insert: 插入元素到第i个位置
* delete: 删除第i个位置的元素，并返回元素的值

### 线性表的存储结构
* **顺序存储结构**: 用一段地址连续的存储单元一次存储线性表的数据元素
	* 数组实现

* **链式存储结构**
> 存储单元可连续，也可不连续。每个数据元素有一个数据域，一个或两个指针域，把它们合称为一个结点。  
数据域存储数据信息，指针域保存直接后继或直接前驱的位置。把n个结点链结成一个链表，即为线性表的链式存储结构。  

	* 单链表: 只有一个指针域指向直接后继
	* 双向链表: 有两个指针域,分别指向直接前驱和后继

## 树
> 树时n(>=0)个结点的有限集，n=0时称为空树，又且只有一个结点是树的根。

* 结点的度: 结点拥有的子树的数目
* 树的度: 树内各结点的度的最大值
* 叶子结点: 度为0的结点
* 孩子结点: 结点的子树的根称为该结点的孩子
* 双亲: 一个结点是其孩子结点的双亲
* 兄弟: 同一个双亲的孩子互称兄弟
* 树的深度或高度: 树中结点的最大层次,层次从1开始，根为第一层
* 有序树: 结点各子树从左到右是有次序的，不能互换
* 森林: m(>=0)棵互不相交的树的集合

### 树的存储结构
* **双亲表示法**: 除根外每个结点不一定有孩子，但一定有双亲
	* 结点数据结构
		* data: 数据域
		* parent: 双亲在数组中的位置
		* firstchild: 结点的第一个左孩子在数组中的位置，称为长子
		* rightsib: 结点的右兄弟的位置

> 注意: 假设在连续内存上存储结点,如数组。其中data和parent是必须的，其它只是为了查找方便增加的。

* **多重链表表示**: 即每个结点有多个指针域，每个指针指向一棵子树的根节点
	* 方案一: 每个结点的指针域的数量相等，等于树的度，即各结点度的最大值
	* 方案二: 每个结点有一个度degree表示当前结点的度，和数量为degree的指针域

* **孩子表示法**: 每个结点的孩子用但链表存储，结点的数据和孩子的链表头指针存在数组中
	* 表头数组的数据结构
		* data: 结点的数据域
		* firstchild: 该结点的孩子链表的头指针
		* parent: 双亲在数组中的位置，不是必须的
	* 孩子链表的数据结构
		* child: 孩子在数组中的位置
		* next: 指向下一个孩子
* **孩子兄弟表示法**: 设置两个指针，分别指向该结点的第一个孩子，和该结点的右兄弟
	* 数据结构
		* data: 数据域
		* firstchild: 指向第一个孩子
		* rightsib: 指向一个右兄弟
		* parent: 指向双亲，不是必须的

### 二叉树
* **二叉树的特点**
	* 每个结点最多只有两棵子树，结点的度最大为2
	* 左子树和右子树是有序的
	* 即使某个结点只有一棵子树也要区分左右
* **特殊二叉树**
	* 斜二叉树
		* 所有结点只有左子树为左斜树
		* 所有结点只有右子树为右斜树
	* 满二叉树: 所有分支结点都存在左子树和右子树，所有叶子结点都在同一层
	* 完全二叉树: 对一棵具有n个结点的二叉树按层序编号，编号为i(1<=i<=n)的结点  
	与同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同
> 完全二叉树有一个很重要的特点: 同样结点数的二叉树，完全二叉树深度最小

* **二叉树的性质**
	* 二叉树的第i层最多有2^(i-1)(i>=1)个结点
	* 深度为k的二叉树最多有2^k-1(k>=1)个结点
	* 对任意一棵二叉树，如果其叶子结点数为n0,度为2的结点数为n2,则n0=n2+1
	* 具有n个结点的完全二叉树的深度为[log2(n)]+1,([x]表示不大于x的最大整数)
	* 对一棵有n个结点的完全二叉树的结点按层序编号(第1层到[log2(n)]+1层),对任一结点(1<=i<=n)有:
		* 若i=1为根，无双亲；i>1,双亲是结点[i/2]
		* 若2i>n,结点i无左孩子(结点i为叶子结点);否则其左孩子是结点2i
		* 若2i+1>n,结点i无右孩子；否则右孩子是结点2i+1

* **二叉树的存储**
	* 顺序存储: 按完全二叉树进行层序编号，依次存入数组相应下标位置，如果编号处无结点，直接空着
	* 二叉链表: 数据域，左孩子指针，右孩子指针

* **二叉树的遍历**
	* 前序遍历: 先访问根结点，再前序遍历左子树，然后前序遍历右子树
	* 中序遍历: 从根结点开始(注意不是先访问),中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树
	* 后序遍历: 从左到右先叶子后结点的方式遍历访问左右子树，左后访问根结点
	* 层序遍历: 从第一层开始从上往下，在同一层从左向右对结点逐个访问
	* 二叉树遍历的性质:
		* 已知前序遍历和中序遍历序列，可以唯一确定一棵二叉树
		* 已知后序遍历和中序遍历序列，可以唯一确定一棵二叉树
		* 已知前序遍历和后序遍历序列，**不能**唯一确定一棵二叉树
	 
> 二叉树的四种遍历实际是把树中的结点变成某种意义上的线性序列,而对于计算机来说它只能处理线性序列

### 树、森林和二叉树的转换
...

### 哈夫曼树和哈夫曼压缩
* 路径长度: 从树中一个结点到另一个结点的分支数目
* 树的路径长度: 从根结点到每个结点的路径长度之和
* 结点的带权路径长度: 从该结点到根之间的路径长度与各结点上权的乘积
* 树的带权路径长度: 树中所有叶子结点的带权路径长度之和。
* 哈夫曼树: 带权路径长度最小的二叉树
* **构造哈夫曼树**
	1. 把带权值的叶子结点按照从小到大排序得到一个序列
	2. 取两个最小的结点构造一个新的双亲结点，较小的为左孩子，新结点的权值为二者权值之和
	3. 用新构造的结点替换两个孩子结点，插入序列,并保持从小到大的顺序
	4. 重复2、3步骤直到序列只剩一个结点，即为哈夫曼树的根结点
* **利用哈夫曼树进行图片压缩**(假设只有灰度一个量)
	1. 量化,对所有像素值出现的频率进行统计，比如像素值为10的出现了30次，100的出现了80次
	2. 以每种像素值作为叶子结点，出现的频率作为其权重,构造一棵哈夫曼树
	3. 以左路径作为0,右路径作为1,从根节点出发到叶子结点的路径即为对应像素值的编码，比如0101
	

## 搜索算法
### 二叉排序树
> 二叉排序树又称为二叉搜索树，它是一棵空树，或满足下列条件的二叉树: 
* 若左子树不为空，左子树上的所有结点值均小于它的根节点值
* 若右子树不为空，右子树上的所有结点值均大于它的根节点值
* 它的左右子树又分别是一棵二叉排序树
> 注意: 在二叉排序树中查找某个结点最多不超过树的深度，因此二叉搜索树的查找性能取决于树的形状(深度)

### 平衡二叉树
> 平衡二叉树是一种二叉排序树，其中每个结点的左子树和右子树的高度差至多等于1  
> 平衡二叉树的深度和完全二叉树的深度相等[log2(n)]+1(但定义上不是平衡二叉树),所以它的查找效率是O(logn)  
> 通过"左旋","右旋转"可以构造出平衡二叉树

### 散列(哈希表)
> 将存储位置和它的关键字建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)

* **散列函数**: 关键字到存储位置的映射函数
	* 设计原则
		* 计算简单
		* 散列地址分布均匀
	* 散列函数构造方法
		* 直接定址法: 关键字直接作为地址
		* 数字分析法: 关键字是多位数字时，可以进行反转叠加等处理
		* 平方取中法: 对关键字平方，取中间几位
		* 折叠法: 分组叠加，然后根据长度取前几位
		* 除留余数法: 除以p(通常取小于或等与表长的最小质数)取余数
		* 随机数法: 取关键字的随机函数值
* **散列冲突解决方法**
> 散列函数有一个特点: 不同的输出一定对应不同的输入，但是不同的输入可能得到相同的输出，因此会有冲突
	* 开放地址法: 只要发生冲突就寻找下一个空的散列地址，只要表够大就一定能找到
		* 公式: f(key) = (f(key)+di) mod(m) (di=1,2,3,...,m-1) 
> 比如f(key) = key mod 12,当发现冲突时就(f(key)+1) mod 12, 如果还冲突就(f(key)+2) mod 12...
	* 再散列法: 准备多个不同的散列函数
		* 公式: f(key) = RHi(key) (i=1,2,3,...,k)
	* 链地址法: 将相同散列地址的记录放在一张单链表中,不需要处理冲突,但是有冲突的查找需要遍历链表带来性能问题
> 比如key-value: a-100,b-200两条记录的关键字通过hash函数冲突了,两条记录存在一张单链表中,假设现在要获取关键字b的数据,   
hash后得到一个地址发现单链表指针不为null,因此知道有冲突,遍历单链表,先找到a,关键字不对,继续找到b,取出value 200

## 排序算法
> 排序的稳定性: 对关键字进行排序，如果多个关键字的值相同，排序前后它们的顺序保持不变，就是稳定排序。

### 影响排序性能的三个方面
* 时间性能: 高效的排序应该尽可能减少关键字比较的次数和记录移动的次数
* 辅助空间: 除了存放待排序所占空间外，执行算法所需的其他空间
* 算法复杂度: 算法本身的复杂度，不是时间复杂度

### 经典排序算法
| 排序算法 | 平均情况 | 最好情况 | 最坏情况 | 辅助空间 | 稳定性 |
|  :---:   |  :---:   |  :---:   |  :---:   |  :---:   |  :---: |
| 冒泡排序 | O(n^2)   | O(n)     | O(n^2)   | O(1)     | 稳定   |
| 简单选择排序 | O(n^2) | O(n^2) | O(n^2)   | O(1)     | 稳定   |
| 直接插入排序 | O(n^2) | O(n)   | O(n^2)   | O(1)     | 稳定   |
| 希尔排序 | O(nlogn)-O(n^2) | O(n^1.3) | O(n^2) | O(1) | 不稳定 |
| 堆排序   | O(nlogn) | O(nlogn) | O(nlogn) | O(1)     | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n)     | 稳定   |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2)   | O(logn)-O(n) | 不稳定 | 
