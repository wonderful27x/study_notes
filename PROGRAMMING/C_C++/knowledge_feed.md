//======================C++_Primer[书店程序][1]======================
[1]:<https://github.com/wonderful27x/C-_Primer_Practice/tree/main/bookstore>
//为什么要学习书店程序？
//书店程序是C++_Primer经典用例，使用c++11语言，面向对象的思想解决实际问题
//该程序涵盖了c++语言的众多必备知识点，是对理解和掌握c++的最佳实践之一
//该程序包含的c++知识点(可能有未总结到的)：
//一.基础知识
//	引用
//	指针
//	顶层const，底层const
//	函数，实参和形参，实参的初始化
//	初始化，赋值
//	直接初始化,拷贝初始化
//二.类
//	构造函数,初始值列表，内类初始值，构造函数执行流程, 成员初始化顺序
//	默认构造函数，合成的默认构造函数,默认构造函数调用时机,default
//	拷贝构造函数，拷贝赋值运算符,合成的版本
//	构造函数的explicit显示调用，隐式转换
//	成员函数，inline内联函数，隐式this指针，const限定符
//	运算符重载,成员函数，非成员函数
//	重载的调用运算符(),函数对象
//	名字查找与类的作用于page 254
//	类的访问修饰符
//
//三.模板
//	函数模板
//	类模板
//	模板的实例化
//	特例化
//四.友元
//	友元，类，模板在应用中的关系
//五.IO
//	标准输入，标准输出，标准错误
//	cin,cout,cerr
//六.命名空间
//	using声明，using指示
//	命名空间中的名字查找
//	名字冲突，命名空间污染
//七.头文件/源文件
//	声明和定义
//	什么时候定义在头文件，什么时候定义在源文件
//	模板特例化的影响
//八.异常处理
//	throw和catch,throw异常对象和catch异常声明与静态编译类型的关系
//	异常查找和匹配流程
//	异常处理流程
//	被析构的代码
//	异常处理后代码恢复执行点


//书店程序简介：
//一个用来记录书的销售记录的应用程序
//Book_sale类是销售记录的抽象数据类型,它包含以下关键成员
//bookNo:书本编号，代表一本书籍
//units_sold:代表bookNo对应的这本书的销售数量
//revenue:代表这本书的销售总额
//注意每个Book_sale对象记录的是bookNo对应的这一本书的销售记录
//一个书店会产生很多这样的记录，比如每天的记录，每个月的记录，每年的记录
//因此每个具有相同bookNo的Book_sale对象可以相加以合并这些相同书籍的销售记录


//====================[文本查询程序][2]-接口设计========================
[2]:<https://github.com/wonderful27x/C-_Primer_Practice/tree/main/text_query>
//该程序涵盖的知识点：
//一.OOP面向对象程序设计
//	构造函数(执行流程、成员初始化顺序、子类父类构造函数调用先后顺序)
//	合成版本的拷贝构造函数和拷贝赋值元算符
//	普通类的名字查找
//	继承体系名字查找-函数调用解析过程
//	析构函数(执行流程、成员销毁顺序、子类父类析构函数调用先后顺序)
//	析构函数调用时机
//	虚函数
//	纯虚函数
//	虚函数属性被继承
//	动态绑定
//	抽象类
//	访问控制与继承
//      拷贝控制成员的作用
//      三五法则，什么时候应该定义拷贝控制成员
//      拷贝成员的合成版本规则(普通类和继承体系)
//      被删除的合成拷贝成员规则(普通类和继承体系)
//      移动成员的合成版本规则(普通类和继承体系)
//      被删除的合成移动成员规则(普通类和继承体系)
//      析构函数组织移动操作规则(普通类和继承体系)
//	
//
//二.容器
//	顺序容器vector
//	关联容器map，set
//	有序容器,对关键字的比较要求
//	无序容器
//	可重复关键字/不可重复关键字
//	map的find和下标运算的区别
//	迭代器，迭代器范围
//	关联容器的关键数据成员key_type,mapped_type,value_type
//	pair
//	算法，算法永远不执行容器操作
//
//
//三.动态内存
//	智能指针shared_ptr,make_shared
//	智能指针也是模板
//	引用计数
//	智能指针智能用于动态内存
//
//
//四.其他
//	局部静态对象
//	auto,推演
//	范围for循环



//文本查询应用的继承体系
//在文本查询中TextQuery拥有查询某个单词的能力，但是查询还需要&、|、~等操作，
//它们通常是对某个单词的查询结果的交并集和取反，因此像这样的操作并不适合继承
//TextQuery,而是使用TextQuery,我们将自己封装一套继承体系
//				Query_base
//	    _________________________|____________________
//         |                         |                    |
//	WordQuery                NotQuery             BinaryQuery  
//	                                      ____________|_______
//                                           |                    |
//	                                   AndQuery             OrQuery
//Query_base提供统一查询接口，抽象基类
//WordQuery实现单个单词查询
//NotQuery实现~查询
//BinaryQuery是一个拥有两个查询对象的抽象基类
//AndQuery实现&查询
//OrQuery实现|查询
//
//注意上面是查询操作程序设计的继承体系，对于查询用户我们应该隐藏这些复杂的细节
//因此我们提供一个用户层面的接口Query,是查询程序的使用变得简单
//一个复杂的符合查询设计成这样:
//(查询fiery和bird在一行同时出现，或者一行出现了wind的结果)
//Query q = Query("fiery") & Query("bird") | Query("wind");
//Query于继承体系的关系图:
//                                             |___  WordQuery -> fiery
//                             |___ AndQuery --|___  WordQuery -> bird
//	q = Query -- OrQuery --|
//                             |___ WordQuery -> wind
//
//
// * &运算符生成一个绑定到新的AndQuery对象上的Query对象
// * |运算符生成一个绑定到新的OrQuery对象上的Query对象
// * ~运算符返回一个绑定到新的NotQuery对象上的Query对象


//=================[message folder][3]应用程序===================
[3]:<https://github.com/wonderful27x/C-_Primer_Practice/tree/main/message_copy_move>
//为什么要学习这个程序？
//C++ Primer经典范例，主要教会我们如何在c++程序中正确的使用拷贝控制，
//拷贝控制是c++比较难的点，但是c++程序总会隐式或显示的使用拷贝控制，
//不掌握拷贝控制通常在程序隐式发生拷贝操作时发生令我们无法理解的错误，
//另一方面正确运用拷贝控制往往给程序带来性能提升，所以拷贝控制是难点也是重点

//程序涵盖的知识点:
//	默认构造函数，默认实参,默认构造函数调用时机
//	拷贝控制成员
//	拷贝构造函数,拷贝构造函数调用时机
//	拷贝赋值运算符
//	移动构造函数
//	移动赋值运算符
//	析构函数,析构函数调用时机
//	拷贝控制成员的作用
//	三五法则，什么时候应该定义拷贝控制成员
//	拷贝成员的合成版本规则(普通类和继承体系)
//	被删除的合成拷贝成员规则(普通类和继承体系)
//	移动成员的合成版本规则(普通类和继承体系)
//	被删除的合成移动成员规则(普通类和继承体系)
//	析构函数组织移动操作规则(普通类和继承体系)
//	=default、=delete
//	右值引用
//	std::move
//	拷贝成员参数的const
//	swap
//	using指示和using声明，扩展的重载函数集
//	移动操作保证移后源的安全析构
//	拷贝构造函数，拷贝赋值运算符和析构函数所做的工作
//	移动操作于noexcept
//	赋值运算符的自赋值情况
//	delete,delete 非动态分配的内存，多次delete


//程序简介:
//程序有两个类Message和Folder
//Message代表一个消息，Folder代表消息的目录
//一个Message可以出现在多个Folder中，它拥有一个保存Folder指针的set
//一个Folder包含多个Message,也有一个set保存Message指针
